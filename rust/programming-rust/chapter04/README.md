# Chapter04 소유와 이동

1. 가비지 컬렉션을 사용하여 메모리를 관리하는 경우
    - 대상을 잃은 포인터가 생기는 것을 방지
    - 그러나 객체에 대한 통제를 잃는다.
2. 엔지니어가 메모리를 관리하는 경우
    - 객체에 대한 통제를 유지
    - 그러나 대상을 잃은 포인터가 생길 수 있다.

러스트는 프로그램이 구사할 수 있는 포인터의 용법에 제약을 두는 기발한 방법으로 이 문제를 해결한다.

## 소유

러스트에서는 소유의 개념이 언어 자체에 내장되어 있으며, 컴파일 시점 검사를 통해 검증된다. 따라서 소유권과 관련된 어떤 것도 런타임 비용을 발생시키지 않는다.

### 소유권 규칙

1. 모든 값은 자신의 수명을 결정하는 소유자가 존재한다.
2. 오직 하나의 소유자만이 그 값의 소유자가 될 수 있다.
3. 소유자가 해제(드롭)될 때 그가 소유한 값도 드롭된다.

```rust
fn print_hello_world() {
    let mut s = String::from("hello"); // s는 String 값의 소유자
    s.push_str(", world!"); // String 값에 문자열을 추가
    println!("{}", s); // hello, world!
} // s가 스코프를 벗어나면 String 값이 드롭된다.
```

s의 버퍼의 포인터, 길이, 용량을 가리키는 세 개의 워드가 print_hello_world 함수의 스택 프레임에 저장된다.
버퍼는 힙에 저장되어 있으며, 문자열 데이터를 가지고 있다.
s는 버퍼를 소유하고 있으며, 변수 s가 함수의 끝에서 스코프를 벗어나면 String이 드롭되고, 버퍼도 해제된다.

Box 타입은 소유의 또 다른 예이다. Box는 힙에 저장된 값에 대한 포인터이며, Box가 스코프를 벗어나면 그 값도 드롭된다.
Box::new(v) 호출은 힙 공간을 할당하고, 값 v를 그리로 옮긴 뒤, 그 힙 공간을 가리키는 포인터를 반환한다.

```rust
{
    let point = Box::new((0.625, 0.5)); // 튜플을 박스로 감싼다.
    let label = format!("{:?}", point); // 포맷 매크로를 사용한다.
    assert_eq!(label, "(0.625, 0.5)");
} // point와 label이 스코프를 벗어나면 드롭된다.
```

변수가 자신의 값을 소유하듯이 스트럭트는 자신의 필드를 소유한다. 마찬가지로 튜플, 배열, 벡터 역시 자신의 요소를 소유한다.

```rust
fn print_struct() {
    struct Person {
        name: String,
        birth: i32,
    }

    let mut composers = Vec::new(); // composers는 Vec<Person> 값의 소유자
    composers.push(Person {
        // Person 구조체는 자신의 필드의 소유권을 가진다.
        name: "Palestrina".to_string(), // 문자열 필드는 String 값의 소유권을 가진다.
        birth: 1525,
    });
    composers.push(Person {
        name: "Dowland".to_string(),
        birth: 1563,
    });
    composers.push(Person {
        name: "Lully".to_string(),
        birth: 1632,
    });

    for composer in &composers {
        println!("{}, born {}", composer.name, composer.birth);
    }
} // composers가 스코프를 벗어나면 Vec<Person> 값이 드롭된다. 그리고 관련된 모든 값들도 드롭된다.
```

문자열 필드는 String 값의 소유권을 가지고 있으며, Person 구조체는 자신의 필드의 소유권을 가진다. 그리고 Vec<Person> 값은 자신의 요소의 소유권을 가진다. 이렇듯 소유자와 이들이 소유한 값은 트리 형태를 이룬다. 각 트리의 최종 루트는 변수다. 이 변수가 스코프를 벗어나면 트리의 모든 값이 드롭된다.

러스트는 C나 C++이 free와 delete를 호출하는 것과 달리, 소유자가 스코프를 벗어나거나 벡터에서 요소를 제거하는 등의 방법을 통해 값이 드롭되는 것을 보장한다.

소유의 개념은 때로는 너무 엄격해서 사용하기가 어렵다. 이에 러스트는 다음과 같은 방법을 통해서 소유의 개념을 확장한다.

1. 값을 한 소유자에게서 다른 소유자로 옮길 수 있다.
2. 정수, 부동소수점 수, 문자 같은 아주 단순한 타입들은 소유 규칙의 적용 대상에서 제외된다. 이런 타입을 Copy 타입이라고 한다.
3. 표준 라이브러리를 통해 러스트는 Rc<T>와 Arc<T> 같은 타입을 제공한다. 이 타입들은 여러 소유자를 허용한다.
4. 값의 레퍼런스를 빌릴 수 있다. 레퍼런스는 한정된 수명을 가진 소유권 없는 포인터이다.

---