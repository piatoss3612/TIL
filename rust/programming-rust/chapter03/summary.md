# Chapter03 기본 타입

## 러스트는 강타입 언어이지만 유연하다.

러스트에서는 함수의 인수와 반환값, 구조체의 필드, 그리고 기타 구문 요소 몇 가지의 타입을 반드시 명시해야 한다. 하지만 러스트는 두 기능을 통해서 동적 타입 언어가 가진 가독성과 유연성을 제공한다.

### 1. 타입 추론

러스트는 타입을 명시하지 않아도 컴파일러가 타입을 추론할 수 있는 경우가 많다. 예를 들어, 다음 코드에서는 변수 `v`의 타입을 명시하지 않았지만 컴파일러가 `i16 타입의 벡터`로 추론한다.

```rust

```rust
fn build_vector() -> Vec<i16> {
    // let mut v: Vec<i16> = Vec::<i16>::new(); // 반환값의 타입을 명시적으로 지정하여 i16 타입의 벡터를 반환한다.
    let mut v = Vec::new(); // 반환값의 타입에 따라 타입을 추론하여 i16 타입의 벡터를 반환한다.
    v.push(10);
    v.push(20);
    v
}
```

러스트는 타입 추론을 통해 코드를 간결하게 만들어주고, 타입을 명시하지 않아도 코드를 읽기 쉽게 만들어준다. 그러면서도 컴파일러가 타입을 추론할 수 없는 경우에는 컴파일 에러를 발생시켜 타입 안정성을 보장한다.

### 2. 제너릭 함수

러스트는 제너릭 함수를 통해 파이썬이나 자바스크립트와 같은 동적 타입 언어의 유연성을 제공한다. 제너릭 함수는 함수의 인수나 반환값의 타입을 명시하지 않고도 여러 타입의 인수와 반환값을 처리할 수 있게 해준다. 파이썬이나 자바스크립트에서는 함수의 인수나 반환값의 타입을 명시하지 않기 때문에 컴파일 시점에 타입 안정성을 보장할 수 없다. 하지만 러스트는 제너릭 함수를 통해 컴파일 시점에 타입 안정성을 보장한다.

---

## 러스트의 기본 타입

<!-- 테이블 작성 -->
| 타입 | 설명 | 예시 |
|:---:|:---:|:---:|
| i8, i16, i32, i64, i128 | 부호 있는 정수 타입 | 42, -1, 0x2Ai32 |
| u8, u16, u32, u64, u128 | 부호 없는 정수 타입 | 42u32, 0x2Au32 |
| isize, usize | 머신 주소 크기(32비트 또는 64비트)의 부호 있는 정수와 부호 없는 정수 타입 | 42isize, 0x2Ausize |
| f32, f64 | 부동소수점 타입 | 42.0, -1.0, 0x2A.0f32 |
| bool | 불리언 타입 | true, false |
| char | 32비트 유니코드 문자 타입 | 'a', 'b', 'c' |
| () | 유일한 값으로서, 유닛 타입(빈 튜플) | () |
| (char, u8, i32) | 타입 혼용이 가능한 튜플 타입 | ('a', 0x2A, -1) |
| Struct S { f: i32 } | 필드 f를 가진 구조체 타입 | S { f: 42 } |
| Struct T (i32, char, u8) | 필드가 없는 튜플 구조체 타입 | T(42, 'a', 0x2A) |
| Struct E | 필드가 없는 유닛형 구조체 타입 | E |
| enum E { A, B } | A와 B 두 가지 값을 가지는 열거형 타입 | E::A, E::B |
| Box<T> | 힙에 할당된 T 타입의 값에 대한 소유권을 가지는 포인터 타입 | Box::new(42) |
| &T &mut T | 공유된 레퍼런스와 가변 레퍼런스 타입 | &42, &mut 42 |
| String | 동적으로 할당된 UTF-8 문자열 타입 | String::from("hello"), "hello".to_string() |
| &str | str 레퍼런스: 소유권을 가지지 않는 UTF-8 문자열 포인터 | "hello", &s[0..3] |
| [T; N] | N개의 T 타입 값으로 구성된 고정 크기 배열 | [42; 0x2A] |
| Vec<T> | 요소의 타입이 모두 같은 가변 길이 벡터 | vec![42, 0x2A] |
| &[T] &mut [T] | 슬라이스 레퍼런스: 소유권을 가지지 않는 가변 길이 배열 포인터 | &v[0..2], &mut v[0..2] |
| Option<T> | 옵션값: None 또는 Some(T) | Some(42), None |
| Result<T, E> | 실패할 수도 있는 작업의 결과: Ok(T) 또는 Err(E) | Ok(42), Err("error") |
| &dyn Trait, &mut dyn Trait | 트레잇 객체 레퍼런스: 트레잇 객체의 소유권을 가지지 않는 트레잇 포인터 | value as &dyn Any, &mut file as &mut dyn Read |
| fn(T) -> U | 함수 포인터: T 타입의 인수를 받아 U 타입의 값을 반환하는 함수 포인터 | str::is_empty |
| 클로저 | 클로저 타입 | { |x: i32| x + 1 } |

---

## 고정된 크기를 갖는 수치 타입

고정된 크기를 갖는 수치 타입은 오버플로를 일으키거나 정밀도를 잃을 수 있찌만, 빠르고 예측 가능한 연산을 제공한다.

### 정수 타입

정수 타입은 부호 있는 정수 타입과 부호 없는 정수 타입으로 나뉜다. 러스트는 부호 있는 정수 타입과 부호 없는 정수 타입을 각각 8비트, 16비트, 32비트, 64비트, 128비트 크기로 제공한다. 또한 머신의 주소 크기에 따라 부호 있는 정수 타입(isize)과 부호 없는 정수 타입(usize)을 제공한다. 머신의 주소 크기는 32비트 또는 64비트이다.

러스트는 바이트값에 u8 타입을 사용한다. 또한 char는 u8도 아니고 u32도 아니다.

usize와 isize는 머신의 주소 크기에 따라 32비트 또는 64비트 크기를 갖는다. 따라서 32비트 머신에서는 usize와 isize가 각각 u32와 i32 타입을 갖는다. 64비트 머신에서는 usize와 isize가 각각 u64와 i64 타입을 갖는다. 러스트에서 배열의 인덱스는 usize 타입이다.

러스트에서 정수 리터럴은 타입을 나타내는 접미사를 가질 수 있다. 예를 들어, 42i32는 i32 타입의 42를 나타낸다. 정수 리터럴에 타입 접미사가 생략되어 있으면 타입 추론을 통해 타입을 결정하며 타입 추론은 리터럴의 사용 문맥에 따라 결정된다. 만약 후보 타입이 여러 개이면 그 중 i32 타입이 존재하면 i32 타입으로 결정하고, 그렇지 않으면 판단이 모호하다는 컴파일 에러를 발생시킨다.

0x, 0o, 0b 접두사를 사용하여 16진수, 8진수, 2진수 리터럴을 나타낼 수 있다.

길이가 긴 숫자는 밑줄(_)을 사용하여 자릿수를 구분할 수 있다.

러스트는 수치 타입과 char를 별개로 취급하는 대신, u8 값으로 쓸 수 있는 문자형 리터럴인 '바이트 리터럴'을 제공한다. 예를 들어 A의 아스키 코드가 65이므로 b'A'는 65u8과 같다. 바이트 리터럴은 u8 값의 또 다른 표기법에 지나지 않으므로, 상황에 따라 어떤 것이 더 의미가 있는지에 따라 선택하면 된다.

as 연산자를 쓰면 한 정수 타입을 다른 정수 타입으로 변환할 수 있다.

```rust
assert_eq!(10_i8 as i16, 10_i16);
assert_eq!(2525_u16 as i16, 2525_i16);

assert_eq!(-1_i16 as i32, -1_i32); // 음수를 보다 큰 타입으로 변환할 때는 빈 공간을 부호로 채운다.
assert_eq!(65535_u16 as i32, 65535_i32); // 양수를 보다 큰 타입으로 변환할 때는 빈 공간을 0으로 채운다.

// 보다 작은 타입으로 변환할 때는 값이 잘린다.
assert_eq!(1000_i16 as u8, 232_u8);
assert_eq!(65535_u16 as i32, 65535_i32);

// 부호가 없는 타입 <-> 부호가 있는 타입
assert_eq!(-1_i8 as u8, 255_u8); // -1은 11111111이므로 부호가 없는 타입으로 변환하면 255가 된다.
assert_eq!(255_u8 as i8, -1_i8); // 255는 11111111이므로 부호가 있는 타입으로 변환하면 -1이 된다.
```

표준 라이브러리는 정수 연산 몇 가지를 메서드 형식으로 제공한다.

```rust
assert_eq!(2_u16.pow(4), 16);
assert_eq!((-4_i32).abs(), 4);
assert_eq!(0b101101_u8.count_ones(), 4);
```

### 점검, 순환, 포화, 넘침 산술

아래와 같은 루프는 오버플로를 일으키며 이는 디버그 빌드에서 패닉을 일으킨다.
반면 릴리즈 빌드에서는 연산의 결과가 끝에서 끝으로 순환되어 루프가 무한히 반복된다.
이러한 동작이 맘에 들지 않으면 정수 타입이 제공하는 메서드를 사용하여 원하는 바를 직접 기재할 수 있다. 이러한 정수 산술 메서드는 크게 점검, 순환, 포화, 넘침 산술로 나뉜다. 이러한 메서드를 사용하면 디버그 빌드와 릴리즈 빌드에서 동일한 동작을 보장할 수 있다.

```rust
fn main() {
    let mut i = 1;
    loop {
        i *= 10;
    }
}
```

#### 1. 점검

- 점검 연산은 연산 결과를 Option에 담아서 반환한다. 수학적으로 옳은 결과를 얻을 수 없는 연산을 수행하면 None을 반환한다.

```rust
assert_eq!(10_u8.checked_add(20), Some(30)); // 더하기 연산의 결과가 타입의 범위를 넘지 않으면 Some(결과값)을 반환한다.
assert_eq!(100_u8.checked_add(200), None); // 더하기 연산의 결과가 타입의 범위를 넘으면 None을 반환한다.
assert_eq!((-128_i8).checked_div(-1), None); // i8 타입의 최소값을 -1로 나누면 타입의 범위를 넘어서므로 None을 반환한다.
```

#### 2. 순환

- 순환 연산은 수학적으로 옳은 결과를 주어진 값의 범위로 나눈 나머지를 반환한다.

```rust
assert_eq!(100_u16.wrapping_mul(200), 20000); // 곱하기 연산의 결과가 타입의 범위를 넘지 않으면 결과값을 반환한다.
assert_eq!(500_u16.wrapping_mul(500), 53392); // 곱하기 연산의 결과가 타입의 범위를 넘으므로 결괏값을 2^16으로 나눈 나머지를 반환한다.

assert_eq!(500_i16.wrapping_mul(500), -12144); // 부호가 있는 타입을 대상으로 곱하기 연산을 수행하면 결과값이 음수로 순환할 수 있다.

assert_eq!(5_i16.wrapping_shl(17), 10); // 16비트 크기의 정수에 대해 17비트만큼 왼쪽으로 시프트하면 1 비트만큼 왼쪽으로 시프트한 것과 같다.
```

#### 3. 포화

- 포화 연산은 수학적으로 옳은 결과를 주어진 값의 범위로 제한한다.

```rust
assert_eq!(32760_i16.saturating_add(10), 32767); // 더하기 연산의 결과가 타입의 범위를 넘었으므로 타입의 최대값을 반환한다.
assert_eq!((-32760_i16).saturating_sub(10), -32768); // 빼기 연산의 결과가 타입의 범위를 넘었으므로 타입의 최소값을 반환한다.
```

#### 4. 넘침

- 넘침 연산은 (result, overflowed) 튜플을 반환한다. 여기서 result는 순환 연산과 같이 수학적으로 옳은 결과를 주어진 값의 범위로 나눈 나머지이다. overflowed는 연산 결과가 타입의 범위를 넘었는지를 나타내는 부울값이다.

```rust
assert_eq!(255_u8.overflowing_sub(2), (253, false)); // 빼기 연산의 결과가 타입의 범위를 넘지 않으면 (결과값, false)를 반환한다.
assert_eq!(255_u8.overflowing_add(2), (1, true)); // 더하기 연산의 결과가 타입의 범위를 넘으면 (순환 결과값, true)를 반환한다.
```

- 단 overflowing_shl과 overflowing_shr 메서드는 자리 이동 거리가 타입의 비트 크기와 같거나 클 때 참을 반환한다.

```rust
// 16비트 크기의 정수에 대해 17비트만큼 왼쪽으로 시프트하면 1 비트만큼 왼쪽으로 시프트한 것과 같으며
// 이동 거리가 타입의 비트 수보다 크므로 true를 반환한다.
assert_eq!(5_u16.overflowing_shl(17), (10, true));
```

> checked_add, sub, mul, div, shl, shr 외에도 rem(나머지), neg(부정), abs(절댓값), pow(거듭제곱) 메서드가 있다.

### 부동소수점 타입

부동소수점 타입은 f32와 f64 두 가지가 있다. f32는 단정도 부동소수점 타입이고, f64는 배정도 부동소수점 타입이다. 기본적으로 러스트는 f64 타입을 사용한다.

부동소수점 수는 정수와의 구분을 위해서 소수 부분, 지수, 타입 접미사 중 하나가 반드시 필요하다.

f32와 f64는 INFINITY, NEG_INFINITY, NAN, MIN, MAX 상수를 제공한다.

```rust
assert!((-1. / f32::INFINITY).is_sign_negative()); // 부호가 있는 부동소수점 음수를 무한대로 나누면 부호가 있는 부동소수점 음수가 된다.
assert_eq!(-f32::MIN, f32::MAX); // 부호가 있는 부동소수점 수의 최소값에 -1을 곱하면 최대값이 된다.
```

부동소수점 타입은 정수 타입과 마찬가지로 수학 계산을 위한 다양한 메서드를 제공한다.

```rust
assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.); // 제곱근을 구한 후 다시 제곱하면 원래 값이 된다.
assert_eq!((-1.01f64).floor(), -2.); // -1.01을 내림하면 -2.0이 된다.
```

---

## 불리언 타입

불리언 타입은 true와 false 두 가지 값만 가질 수 있다. 불리언 타입은 bool 타입으로 표기한다.

러스트의 as 연산자는 bool 값을 정수 타입으로 변환할 수 있다. 그러나 그 반대는 불가능하다.

```rust
assert_eq!(true as i32, 1); // true를 i32 타입으로 변환하면 1이 된다.
assert_eq!(false as i32, 0); // false를 i32 타입으로 변환하면 0이 된다.
```

bool 값을 메모리에 표현하는데는 1비트만 있으면 되지만, 러스트는 1바이트 크기의 메모리를 사용한다. 따라서 bool 값을 가리키는 포인터를 사용할 수 있다.

---

## 문자

러스트는 유니코드 문자를 표현하기 위해 32비트 크기의 char 타입을 제공한다.

문자 리터럴은 작은 따옴표(')로 묶어서 표기한다.

바이트 리터럴의 경우처럼 일부 문자들 앞에는 반드시 백슬래시를 붙여야 한다. (예: '\n', '\t', '\r', '\\', '\'', '\"', '\xNN', '\u{NNNN}')

char는 항상 0x0000에서 0xD7FF 사이나 0xE000에서 0x10FFFF 사이의 유니코드 코드 포인트를 나타낸다. 따라서 0xD800에서 0xDFFF 사이(서로게이트 쌍)의 코드 포인트는 유효하지 않다.

char는 as 연산자를 통해 정수 타입으로 변환할 수 있다. 만약 32비트 크기의 정수 타입보다 작은 값으로 변환할 경우, 상위 비트의 일부가 잘린다.

```rust
assert_eq!('*' as i32, 42); // '*'를 i32 타입으로 변환하면 42가 된다.
assert_eq!('ಠ' as u16, 0xca0); // 'ಠ'를 u16 타입으로 상위 비트가 잘려서 0xca0이 된다.
assert_eq!('ಠ' as i8, -0x60); // 'ಠ'를 i8 타입으로 상위 비트가 잘려서 -0x60이 된다.
```

char는 as 연산자를 사용해 어떤 정수 타입으로든 변환이 가능하지만, char로 변환할 수 있는 정 수 타입은 u8 뿐이다. 그 대신 표준 라이브러리는 u32 값을 받아서 char 타입으로 변환하는 from_u32 메서드를 제공한다.

표준 라이브러리는 이 외에도 char 타입에 대한 다양한 메서드를 제공한다.

```rust
assert_eq!('*'.is_alphabetic(), false); // '*'는 알파벳이 아니다.
assert_eq!('β'.is_alphabetic(), true); // 'β'는 알파벳이다.
assert_eq!('8'.to_digit(10), Some(8)); // '8'은 10진수로 8이다.
assert_eq!('ಠ'.len_utf8(), 3); // 'ಠ'는 UTF-8로 3바이트이다.
assert_eq!(char::from_digit(2, 10), Some('2')); // 10진수 2는 '2'이다.
```

---