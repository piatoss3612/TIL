# Chapter03 기본 타입

## 러스트는 강타입 언어이지만 유연하다.

러스트에서는 함수의 인수와 반환값, 구조체의 필드, 그리고 기타 구문 요소 몇 가지의 타입을 반드시 명시해야 한다. 하지만 러스트는 두 기능을 통해서 동적 타입 언어가 가진 가독성과 유연성을 제공한다.

### 1. 타입 추론

러스트는 타입을 명시하지 않아도 컴파일러가 타입을 추론할 수 있는 경우가 많다. 예를 들어, 다음 코드에서는 변수 `v`의 타입을 명시하지 않았지만 컴파일러가 `i16 타입의 벡터`로 추론한다.

```rust

```rust
fn build_vector() -> Vec<i16> {
    // let mut v: Vec<i16> = Vec::<i16>::new(); // 반환값의 타입을 명시적으로 지정하여 i16 타입의 벡터를 반환한다.
    let mut v = Vec::new(); // 반환값의 타입에 따라 타입을 추론하여 i16 타입의 벡터를 반환한다.
    v.push(10);
    v.push(20);
    v
}
```

러스트는 타입 추론을 통해 코드를 간결하게 만들어주고, 타입을 명시하지 않아도 코드를 읽기 쉽게 만들어준다. 그러면서도 컴파일러가 타입을 추론할 수 없는 경우에는 컴파일 에러를 발생시켜 타입 안정성을 보장한다.

### 2. 제너릭 함수

러스트는 제너릭 함수를 통해 파이썬이나 자바스크립트와 같은 동적 타입 언어의 유연성을 제공한다. 제너릭 함수는 함수의 인수나 반환값의 타입을 명시하지 않고도 여러 타입의 인수와 반환값을 처리할 수 있게 해준다. 파이썬이나 자바스크립트에서는 함수의 인수나 반환값의 타입을 명시하지 않기 때문에 컴파일 시점에 타입 안정성을 보장할 수 없다. 하지만 러스트는 제너릭 함수를 통해 컴파일 시점에 타입 안정성을 보장한다.

---

## 러스트의 기본 타입

<!-- 테이블 작성 -->
| 타입 | 설명 | 예시 |
|:---:|:---:|:---:|
| i8, i16, i32, i64, i128 | 부호 있는 정수 타입 | 42, -1, 0x2Ai32 |
| u8, u16, u32, u64, u128 | 부호 없는 정수 타입 | 42u32, 0x2Au32 |
| isize, usize | 머신 주소 크기(32비트 또는 64비트)의 부호 있는 정수와 부호 없는 정수 타입 | 42isize, 0x2Ausize |
| f32, f64 | 부동소수점 타입 | 42.0, -1.0, 0x2A.0f32 |
| bool | 불리언 타입 | true, false |
| char | 32비트 유니코드 문자 타입 | 'a', 'b', 'c' |
| () | 유일한 값으로서, 유닛 타입(빈 튜플) | () |
| (char, u8, i32) | 타입 혼용이 가능한 튜플 타입 | ('a', 0x2A, -1) |
| Struct S { f: i32 } | 필드 f를 가진 구조체 타입 | S { f: 42 } |
| Struct T (i32, char, u8) | 필드가 없는 튜플 구조체 타입 | T(42, 'a', 0x2A) |
| Struct E | 필드가 없는 유닛형 구조체 타입 | E |
| enum E { A, B } | A와 B 두 가지 값을 가지는 열거형 타입 | E::A, E::B |
| Box<T> | 힙에 할당된 T 타입의 값에 대한 소유권을 가지는 포인터 타입 | Box::new(42) |
| &T &mut T | 공유된 레퍼런스와 가변 레퍼런스 타입 | &42, &mut 42 |
| String | 동적으로 할당된 UTF-8 문자열 타입 | String::from("hello"), "hello".to_string() |
| &str | str 레퍼런스: 소유권을 가지지 않는 UTF-8 문자열 포인터 | "hello", &s[0..3] |
| [T; N] | N개의 T 타입 값으로 구성된 고정 크기 배열 | [42; 0x2A] |
| Vec<T> | 요소의 타입이 모두 같은 가변 길이 벡터 | vec![42, 0x2A] |
| &[T] &mut [T] | 슬라이스 레퍼런스: 소유권을 가지지 않는 가변 길이 배열 포인터 | &v[0..2], &mut v[0..2] |
| Option<T> | 옵션값: None 또는 Some(T) | Some(42), None |
| Result<T, E> | 실패할 수도 있는 작업의 결과: Ok(T) 또는 Err(E) | Ok(42), Err("error") |
| &dyn Trait, &mut dyn Trait | 트레잇 객체 레퍼런스: 트레잇 객체의 소유권을 가지지 않는 트레잇 포인터 | value as &dyn Any, &mut file as &mut dyn Read |
| fn(T) -> U | 함수 포인터: T 타입의 인수를 받아 U 타입의 값을 반환하는 함수 포인터 | str::is_empty |
| 클로저 | 클로저 타입 | { |x: i32| x + 1 } |

---

## 고정된 크기를 갖는 수치 타입

고정된 크기를 갖는 수치 타입은 오버플로를 일으키거나 정밀도를 잃을 수 있찌만, 빠르고 예측 가능한 연산을 제공한다.

### 정수 타입

정수 타입은 부호 있는 정수 타입과 부호 없는 정수 타입으로 나뉜다. 러스트는 부호 있는 정수 타입과 부호 없는 정수 타입을 각각 8비트, 16비트, 32비트, 64비트, 128비트 크기로 제공한다. 또한 머신의 주소 크기에 따라 부호 있는 정수 타입(isize)과 부호 없는 정수 타입(usize)을 제공한다. 머신의 주소 크기는 32비트 또는 64비트이다.

러스트는 바이트값에 u8 타입을 사용한다. 또한 char는 u8도 아니고 u32도 아니다.

usize와 isize는 머신의 주소 크기에 따라 32비트 또는 64비트 크기를 갖는다. 따라서 32비트 머신에서는 usize와 isize가 각각 u32와 i32 타입을 갖는다. 64비트 머신에서는 usize와 isize가 각각 u64와 i64 타입을 갖는다. 러스트에서 배열의 인덱스는 usize 타입이다.

러스트에서 정수 리터럴은 타입을 나타내는 접미사를 가질 수 있다. 예를 들어, 42i32는 i32 타입의 42를 나타낸다. 정수 리터럴에 타입 접미사가 생략되어 있으면 타입 추론을 통해 타입을 결정하며 타입 추론은 리터럴의 사용 문맥에 따라 결정된다. 만약 후보 타입이 여러 개이면 그 중 i32 타입이 존재하면 i32 타입으로 결정하고, 그렇지 않으면 판단이 모호하다는 컴파일 에러를 발생시킨다.

0x, 0o, 0b 접두사를 사용하여 16진수, 8진수, 2진수 리터럴을 나타낼 수 있다.

길이가 긴 숫자는 밑줄(_)을 사용하여 자릿수를 구분할 수 있다.

러스트는 수치 타입과 char를 별개로 취급하는 대신, u8 값으로 쓸 수 있는 문자형 리터럴인 '바이트 리터럴'을 제공한다. 예를 들어 A의 아스키 코드가 65이므로 b'A'는 65u8과 같다. 바이트 리터럴은 u8 값의 또 다른 표기법에 지나지 않으므로, 상황에 따라 어떤 것이 더 의미가 있는지에 따라 선택하면 된다.

as 연산자를 쓰면 한 정수 타입을 다른 정수 타입으로 변환할 수 있다.

```rust
assert_eq!(10_i8 as i16, 10_i16);
assert_eq!(2525_u16 as i16, 2525_i16);

assert_eq!(-1_i16 as i32, -1_i32); // 음수를 보다 큰 타입으로 변환할 때는 빈 공간을 부호로 채운다.
assert_eq!(65535_u16 as i32, 65535_i32); // 양수를 보다 큰 타입으로 변환할 때는 빈 공간을 0으로 채운다.

// 보다 작은 타입으로 변환할 때는 값이 잘린다.
assert_eq!(1000_i16 as u8, 232_u8);
assert_eq!(65535_u16 as i32, 65535_i32);

// 부호가 없는 타입 <-> 부호가 있는 타입
assert_eq!(-1_i8 as u8, 255_u8); // -1은 11111111이므로 부호가 없는 타입으로 변환하면 255가 된다.
assert_eq!(255_u8 as i8, -1_i8); // 255는 11111111이므로 부호가 있는 타입으로 변환하면 -1이 된다.
```

표준 라이브러리는 정수 연산 몇 가지를 메서드 형식으로 제공한다.

```rust
assert_eq!(2_u16.pow(4), 16);
assert_eq!((-4_i32).abs(), 4);
assert_eq!(0b101101_u8.count_ones(), 4);
```

### 점검, 순환, 포화, 넘침 산술

아래와 같은 루프는 오버플로를 일으키며 이는 디버그 빌드에서 패닉을 일으킨다.
반면 릴리즈 빌드에서는 연산의 결과가 끝에서 끝으로 순환되어 루프가 무한히 반복된다.
이러한 동작이 맘에 들지 않으면 정수 타입이 제공하는 메서드를 사용하여 원하는 바를 직접 기재할 수 있다. 이러한 정수 산술 메서드는 크게 점검, 순환, 포화, 넘침 산술로 나뉜다. 이러한 메서드를 사용하면 디버그 빌드와 릴리즈 빌드에서 동일한 동작을 보장할 수 있다.

```rust
fn main() {
    let mut i = 1;
    loop {
        i *= 10;
    }
}
```

#### 1. 점검

- 점검 연산은 연산 결과를 Option에 담아서 반환한다. 수학적으로 옳은 결과를 얻을 수 없는 연산을 수행하면 None을 반환한다.

```rust
assert_eq!(10_u8.checked_add(20), Some(30)); // 더하기 연산의 결과가 타입의 범위를 넘지 않으면 Some(결과값)을 반환한다.
assert_eq!(100_u8.checked_add(200), None); // 더하기 연산의 결과가 타입의 범위를 넘으면 None을 반환한다.
assert_eq!((-128_i8).checked_div(-1), None); // i8 타입의 최소값을 -1로 나누면 타입의 범위를 넘어서므로 None을 반환한다.
```

#### 2. 순환

- 순환 연산은 수학적으로 옳은 결과를 주어진 값의 범위로 나눈 나머지를 반환한다.

```rust
assert_eq!(100_u16.wrapping_mul(200), 20000); // 곱하기 연산의 결과가 타입의 범위를 넘지 않으면 결과값을 반환한다.
assert_eq!(500_u16.wrapping_mul(500), 53392); // 곱하기 연산의 결과가 타입의 범위를 넘으므로 결괏값을 2^16으로 나눈 나머지를 반환한다.

assert_eq!(500_i16.wrapping_mul(500), -12144); // 부호가 있는 타입을 대상으로 곱하기 연산을 수행하면 결과값이 음수로 순환할 수 있다.

assert_eq!(5_i16.wrapping_shl(17), 10); // 16비트 크기의 정수에 대해 17비트만큼 왼쪽으로 시프트하면 1 비트만큼 왼쪽으로 시프트한 것과 같다.
```

#### 3. 포화

- 포화 연산은 수학적으로 옳은 결과를 주어진 값의 범위로 제한한다.

```rust
assert_eq!(32760_i16.saturating_add(10), 32767); // 더하기 연산의 결과가 타입의 범위를 넘었으므로 타입의 최대값을 반환한다.
assert_eq!((-32760_i16).saturating_sub(10), -32768); // 빼기 연산의 결과가 타입의 범위를 넘었으므로 타입의 최소값을 반환한다.
```

#### 4. 넘침

- 넘침 연산은 (result, overflowed) 튜플을 반환한다. 여기서 result는 순환 연산과 같이 수학적으로 옳은 결과를 주어진 값의 범위로 나눈 나머지이다. overflowed는 연산 결과가 타입의 범위를 넘었는지를 나타내는 부울값이다.

```rust
assert_eq!(255_u8.overflowing_sub(2), (253, false)); // 빼기 연산의 결과가 타입의 범위를 넘지 않으면 (결과값, false)를 반환한다.
assert_eq!(255_u8.overflowing_add(2), (1, true)); // 더하기 연산의 결과가 타입의 범위를 넘으면 (순환 결과값, true)를 반환한다.
```

- 단 overflowing_shl과 overflowing_shr 메서드는 자리 이동 거리가 타입의 비트 크기와 같거나 클 때 참을 반환한다.

```rust
// 16비트 크기의 정수에 대해 17비트만큼 왼쪽으로 시프트하면 1 비트만큼 왼쪽으로 시프트한 것과 같으며
// 이동 거리가 타입의 비트 수보다 크므로 true를 반환한다.
assert_eq!(5_u16.overflowing_shl(17), (10, true));
```

> checked_add, sub, mul, div, shl, shr 외에도 rem(나머지), neg(부정), abs(절댓값), pow(거듭제곱) 메서드가 있다.

### 부동소수점 타입

부동소수점 타입은 f32와 f64 두 가지가 있다. f32는 단정도 부동소수점 타입이고, f64는 배정도 부동소수점 타입이다. 기본적으로 러스트는 f64 타입을 사용한다.

부동소수점 수는 정수와의 구분을 위해서 소수 부분, 지수, 타입 접미사 중 하나가 반드시 필요하다.

f32와 f64는 INFINITY, NEG_INFINITY, NAN, MIN, MAX 상수를 제공한다.

```rust
assert!((-1. / f32::INFINITY).is_sign_negative()); // 부호가 있는 부동소수점 음수를 무한대로 나누면 부호가 있는 부동소수점 음수가 된다.
assert_eq!(-f32::MIN, f32::MAX); // 부호가 있는 부동소수점 수의 최소값에 -1을 곱하면 최대값이 된다.
```

부동소수점 타입은 정수 타입과 마찬가지로 수학 계산을 위한 다양한 메서드를 제공한다.

```rust
assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.); // 제곱근을 구한 후 다시 제곱하면 원래 값이 된다.
assert_eq!((-1.01f64).floor(), -2.); // -1.01을 내림하면 -2.0이 된다.
```

---

## 불리언 타입

불리언 타입은 true와 false 두 가지 값만 가질 수 있다. 불리언 타입은 bool 타입으로 표기한다.

러스트의 as 연산자는 bool 값을 정수 타입으로 변환할 수 있다. 그러나 그 반대는 불가능하다.

```rust
assert_eq!(true as i32, 1); // true를 i32 타입으로 변환하면 1이 된다.
assert_eq!(false as i32, 0); // false를 i32 타입으로 변환하면 0이 된다.
```

bool 값을 메모리에 표현하는데는 1비트만 있으면 되지만, 러스트는 1바이트 크기의 메모리를 사용한다. 따라서 bool 값을 가리키는 포인터를 사용할 수 있다.

---

## 문자

러스트는 유니코드 문자를 표현하기 위해 32비트 크기의 char 타입을 제공한다.

문자 리터럴은 작은 따옴표(')로 묶어서 표기한다.

바이트 리터럴의 경우처럼 일부 문자들 앞에는 반드시 백슬래시를 붙여야 한다. (예: '\n', '\t', '\r', '\\', '\'', '\"', '\xNN', '\u{NNNN}')

char는 항상 0x0000에서 0xD7FF 사이나 0xE000에서 0x10FFFF 사이의 유니코드 코드 포인트를 나타낸다. 따라서 0xD800에서 0xDFFF 사이(서로게이트 쌍)의 코드 포인트는 유효하지 않다.

char는 as 연산자를 통해 정수 타입으로 변환할 수 있다. 만약 32비트 크기의 정수 타입보다 작은 값으로 변환할 경우, 상위 비트의 일부가 잘린다.

```rust
assert_eq!('*' as i32, 42); // '*'를 i32 타입으로 변환하면 42가 된다.
assert_eq!('ಠ' as u16, 0xca0); // 'ಠ'를 u16 타입으로 상위 비트가 잘려서 0xca0이 된다.
assert_eq!('ಠ' as i8, -0x60); // 'ಠ'를 i8 타입으로 상위 비트가 잘려서 -0x60이 된다.
```

char는 as 연산자를 사용해 어떤 정수 타입으로든 변환이 가능하지만, char로 변환할 수 있는 정 수 타입은 u8 뿐이다. 그 대신 표준 라이브러리는 u32 값을 받아서 char 타입으로 변환하는 from_u32 메서드를 제공한다.

표준 라이브러리는 이 외에도 char 타입에 대한 다양한 메서드를 제공한다.

```rust
assert_eq!('*'.is_alphabetic(), false); // '*'는 알파벳이 아니다.
assert_eq!('β'.is_alphabetic(), true); // 'β'는 알파벳이다.
assert_eq!('8'.to_digit(10), Some(8)); // '8'은 10진수로 8이다.
assert_eq!('ಠ'.len_utf8(), 3); // 'ಠ'는 UTF-8로 3바이트이다.
assert_eq!(char::from_digit(2, 10), Some('2')); // 10진수 2는 '2'이다.
```

---

## 튜플

튜플은 다양한 타입의 값들을 한데 모아 묶은 것으로, 요소들을 쉼표로 구분한 다음 괄호 안에 넣는다.
튜플 값 t가 있을 때 그 안에 있는 요소는 t.0, t.1과 같은 식으로 접근할 수 있다.

러스트에서 튜플은 배열과 별개로 취급된다. 튜플은 각 요소의 타입이 다를 수 있으나, 배열은 모든 요소의 타입이 같아야 한다.
튜플은 t.2처럼 상수로된 인덱스만 사용할 수 있으며, t.i, t[i]와 같은 식으로는 사용할 수 없다.

러스트에서는 함수에서 여러 개의 값을 반환할 때 튜플을 사용한다. 반환값의 각 요소를 개별 변수에 배정하고자 할 때는 다음처럼 패턴 매칭 문법을 쓰면 된다.

```rust
let text = "I see the eigenvalue in thine eye";
let (head, tail) = text.split_at(21);
assert_eq!(head, "I see the eigenvalue ");
assert_eq!(tail, "in thine eye");
```

튜플은 간단한 스트럭트 타입처럼 사용할 수 있다. 튜플은 필드명이 없으므로 필드명 대신 인덱스를 사용한다.

자주 쓰이는 또 다른 튜플 타입은 제로 튜플인 ()이다. 제로 튜플은 유닛 타입이라고도 부른다. 제로 튜플은 유일한 값으로서, 함수가 값을 반환하지 않을 때 반환값으로 사용된다.

---

## 포인터 타입

포인터 타입은 메모리 주소를 나타내는 타입이다. 러스트는 몇 가지 포인터 타입을 제공한다.

### 1. 레퍼런스

레퍼런스는 러스트의 기본 포인터 타입으로 생각하면 이해하기 쉽다. 레퍼런스는 & 연산자를 사용하여 생성되며 생성된 레퍼런스는 1 머신 워드 크기를 갖는다. 표현식 &x는 x의 레퍼런스를 생성하는데, 러스트에서는 이를 두고 x의 레퍼런스를 빌려 온다고 표현한다. 레퍼런스 r이 있을 때 *r은 r이 가리키는 값을 나타낸다. 이러한 연산을 역참조(dereference)라고 부른다.

러스트 레퍼런스는 절대로 null이 될 수 없다. 레퍼런스는 항상 유효한 메모리 주소를 가리킨다. 그리고 러스트는 값의 소유권과 수명을 추척한다. 따라서 러스트에서는 대상을 잃은 포인터, 중복 해제, 포인터 무효화 같은 실수들이 컴파일 시점에서 배제된다.

### 2. 박스

힙에 값을 할당하고 그 값을 가리키는 포인터를 생성하려면 박스를 사용한다. 박스는 Box<T> 타입으로 표기한다. 박스는 Box::new 함수를 사용하여 생성한다.박스는 레퍼런스와 달리 힙에 할당된 값을 소유한다. 따라서 박스는 레퍼런스와 달리 값의 소유권을 가지며, 박스가 스코프를 벗어나면 박스가 가리키는 값은 해제된다.

### 3. 원시 포인터

원시 포인터는 *const T와 *mut T 두 가지가 있다. 원시 포인터는 레퍼런스와 달리 러스트가 값의 소유권과 수명을 추적하지 않는다. 따라서 원시 포인터는 러스트의 안전성 보장 기능을 무력화한다. 원시 포인터는 러스트에서 가능한 한 사용하지 않는 것이 좋다.

---

## 배열, 벡터, 슬라이스

1. [T; N] - N개의 T 타입 값으로 구성된 고정 크기 배열, N은 컴파일 시점 상수로 배열에 새로운 요소를 추가하거나 배열의 크기를 축소할 수 없다.
2. Vec<T> - 요소의 타입이 모두 같은 가변 길이 벡터, 벡터는 힙에 할당되며, 벡터의 크기는 런타임에 결정된다. 벡터는 요소를 추가하거나 제거할 수 있다.
3. &[T], &mut [T] - 배열이나 벡터의 일부를 가리키는 레퍼런스로, 각각 공유된 T 슬라이스, 변경할 수 있는 T 슬라이스라고 부른다. &mut [T]는 요소를 변경할 수 있지만 공유할 수 없다. &[T]는 다수가 읽을 수 있지만 변경할 수 없다.

값 v의 타입이 위 세 가지 중 하나라고 할 때
1. v.len()은 v의 요소 개수를 반환한다.
2. v[i]는 v의 i번째 요소를 반환한다. 시작 인덱스는 0이다.

### 배열

러스트는 초기화 되지 않은 배열을 위한 표기법이 없다. 배열을 생성하기 위해서는 [1, 2, 3] 또는 [T; N]과 같이 초기화가 필요하다.

배열을 다룰 때 쓰이는 유용한 메스드들은 사실은 배열이 아니라 슬라이스에 대한 메서드이다. 그러나 러스트는 메서드를 찾을 때 암묵적으로 배열 레퍼런스를 슬라이스로 변환하므로 배열에 대한 메서드처럼 사용할 수 있다.

```rust
let mut chaos = [3, 5, 4, 1, 2];
chaos.sort(); // 배열을 정렬한다.
assert_eq!(chaos, [1, 2, 3, 4, 5]);
```

### 벡터

벡터는 Vec<T> 타입으로 표기한다. 벡터의 요소는 모두 힙에 할당된다.

벡터를 초기화하는 방법은 여러 가지가 있다.

우선 vec! 매크로를 사용하는 방법이 있다. vec! 매크로는 벡터의 요소를 나열하여 벡터를 생성한다.

```rust
let mut primes = vec![2, 3, 5, 7];
assert_eq!(primes.iter().product::<i32>(), 210); // 벡터의 모든 요소를 곱한 결과가 210이다.

primes.push(11);
primes.push(13);
assert_eq!(primes.iter().product::<i32>(), 30030); // 벡터의 모든 요소를 곱한 결과가 30030이다.
```

배열 리터럴을 흉내내는 방법도 있다. !vec[T; N]과 같이 벡터의 타입을 명시하고, [T; N]과 같이 배열 리터럴을 사용하여 벡터를 생성한다.

```rust
let rows = 3;
let cols = 5;
let mut table = vec![vec![0; cols]; rows]; // 3행 5열의 2차원 벡터를 생성한다.
table[2][3] = 42;
assert_eq!(table[2][3], 42); // 2행 3열의 요소가 42이다.
```

Vec::new() 메서드를 사용하여 빈 벡터를 생성할 수도 있다.

```rust
let mut pal = Vec::new();
pal.push("step");
pal.push("on");
pal.push("no");
pal.push("pets");
assert_eq!(pal, vec!["step", "on", "no", "pets"]);
```

이터레이터가 넘겨주는 값을 collect 메서드를 사용하여 벡터로 수집할 수도 있다.

```rust
let v: Vec<i32> = (0..5).collect();
assert_eq!(v, [0, 1, 2, 3, 4]);
```

벡터도 배열과 마찬가지로 슬라이스 메서드를 사용할 수 있다.

```rust
let mut palindrome = vec!["a man", "a plan", "a canal", "panama"];
palindrome.reverse(); // 벡터의 요소를 역순으로 정렬한다.

assert_eq!(palindrome, vec!["panama", "a canal", "a plan", "a man"]);
```

Vec<T>는 세 가지 값으로 구성되어 있다. 힙에 할당해 소유하는 버퍼의 포인터, 버퍼가 저장할 수 있는 요소의 개수를 의미하는 용량, 버퍼가 실제로 가지고 있는 요소의 개수를 의미하는 길이가 이에 해당한다. 버퍼의 용량이 다 찬 상태에서 새 요소를 추가하면, 벡터는 더 큰 버퍼를 할당한 뒤에 기존 버퍼의 요소를 새 버퍼로 복사한다. 그리고 포인터, 용량, 길이를 새 버퍼로 갱신한다. 기존의 버퍼는 해제된다. (go의 슬라이스와 비슷한듯)

만약 벡터에 담아야 할 요소의 개수를 미리 알고 있다면 Vec::new 대신 Vec::with_capacity 메서드를 사용하는 것이 좋다. 이 메서드는 벡터의 용량을 미리 할당해 놓으므로, 벡터에 요소를 추가할 때마다 새 버퍼를 할당하고 기존 버퍼의 요소를 복사하는 비용을 줄일 수 있다.

### 슬라이스

슬라이스는 배열이나 벡터의 한 영역으로 별도의 길이 지정 없이 [T]라고 쓴다. 슬라이스는 길이 제한이 없으므로 변수에 직접 저장하거나 함수의 인수로 전달할 수 없다. 대신 슬라이스 레퍼런스 &[T] 또는 &mut [T]를 사용한다.

슬라이스 레퍼런스는 팻 포인터(fat pointer)로, 슬라이스의 첫 번째 요소를 가리키는 포인터와 그 안에 있는 요소의 개수로 구성되는 2워드 크기의 값이다.

일반적인 레퍼런스는 단일 값을 가리키는 소유권이 없는 포인터인 반면, 슬라이스 레퍼런스는 메모리에 있는 연속된 여러 값을 가리키는 소유권이 없는 포인터이다.

---

## 문자열 타입

### 문자열 리터럴

문자열 리터럴은 큰 따옴표(")로 묶어서 표기한다. 문자열 리터럴은 &str 타입을 갖는다. 문자열 리터럴은 불변이다.

### 바이트 문자열

바이트 문자열 리터럴은 b"..."로 표기한다. 바이트 문자열 리터럴은 &[u8] 타입을 갖는다. 이 타입에는 문자열 메서드가 없다.

### 문자열의 메모리 구조

러스트 문자열은 UTF-8로 인코딩된 바이트 시퀀스이다.

String은 UTF-8 텍스트를 담는 버퍼를 가지고 있다. 이 버퍼는 힙에 할당되므로 크기 조절이 가능하다. String은 적격한 UTF-8만 담도록 구성된 Vec<u8>이라고 생각하면 이해하기 쉽다.

&str는 다른 누군가가 소유한 일련의 UTF-8 텍스트를 참조하는 레퍼런스이다. &str는 적격한 UTF-8만 담도록 구성된 &[u8]이라고 생각하면 이해하기 쉽다.

문자열 리터럴은 미리 할당된 텍스트를 가리키는 &str로, 프로그램의 머신 코드와 함께 읽기 전용 메모리에 저장된다.

### String

String은 다양한 방법으로 만들 수 있다.

1. to_string 메서드를 사용하여 &str을 String으로 변환할 수 있다.

```rust
let mut s = "Hello".to_string();
```

2. to_owned 메서드를 사용하여 &str을 String으로 변환할 수 있다.

```rust
let mut s = "Hello".to_owned();
```

3. format! 매크로를 사용하여 여러 개의 값을 이어붙여 String을 생성할 수 있다.

```rust
let temp = format!("{}°{:02}′{:02}″N", 24, 5, 23);
assert_eq!(temp, "24°05′23″N");
```

4. 문자열의 배열, 슬라이스, 벡터를 이어붙여 String을 생성할 수 있다.

```rust
let bits = vec!["veni", "vidi", "vici"];
assert_eq!(bits.concat(), "venividivici");
assert_eq!(bits.join(", "), "veni, vidi, vici");
```

5. String::new() 메서드를 사용하여 빈 문자열을 생성할 수 있다.

```rust
let mut s = String::new();
```

### 문자열 사용하기

문자열은 ==, !=, <, >, <=, >= 연산자를 사용하여 비교할 수 있다. 이 연산자들은 사전식 순서로 문자열을 비교한다.

또한 많은 유용한 메서드와 함수를 지원한다.

```rust
assert!("ONE".to_lowercase() == "one");

assert!("peanut".contains("nut"));
assert_eq!("ಠ_ಠ".replace("ಠ", "■"), "■_■");
assert_eq!("    clean\n".trim(), "clean");

for word in "veni, vidi, vici".split(", ") {
    assert!(word.starts_with("v"));
}
```

### 유사 문자열 타입

프로그램을 만들다 보면 유효한 유니코드가 아닌 문자열을 다루는 경우가 생긴다. 이런 경우에는 러스트의 문자열 타입을 사용할 수 없다. 이런 경우에는 다음과 같은 유사 문자열 타입을 사용할 수 있다.

- 파일 이름을 다룰 때는 std::path::PathBuf와 &Path를 사용한다.
- UTF-8로 인코딩되지 않은 바이트 시퀀스를 다룰 때는 Vec<u8>와 &[u8]를 사용한다.
- 환경 변수 이름과 명령줄 인수를 운영체제의 고유 형식으로 다룰 때는 OsString과 &OsStr를 사용한다.
- 널 종료 문자열을 쓰는 C 라이브러리와 연동할 때는 std::ffi::CString과 &CStr를 사용한다.

---

## 타입 별칭

타입 별칭은 타입에 새 이름을 붙이는 것이다. 타입 별칭은 다음과 같이 표기한다.

```rust
type Bytes = Vec<u8>;

let b: Bytes = From::from("bors".as_bytes());
```