# chapter03 효율성 완전 정복

### 프로그램을 개선할 때 검토해야 할 것들

- 성능 측면에서 향상시킬 것이 있는가?
- 만약 그렇다면, 쓸모없이 돌아가는 주기를 찾아내고, 그 주기를 제거할 수 있는가?
- 특정 기능의 레이턴시를 줄이기 위해 얼마나 많은 작업이 필요한가?
- 줄일 수 있는 초과 할당이 있는가?
- 과도한 네트워크 대역폭 사용을 줄이는 대신 메모리 공간을 희생해야 하는가?

> 3장에서는 이런 질문들에 대한 답을 찾는데 도움의 되는 도구 및 방법론에 대해 알아본다.

## 3.1 낭비 제거 이상의 최적화는 제로섬 게임

#### 최적화

- 제약 조건이 있는 문제에 대한 모든 가능한 해결책 중에서 가장 좋은 해결책을 찾는 것 (공학 분야)
- 시스템이나 프로그램 실행을 특정한 측면에서 향상시키는 작업 (컴퓨터 공학 분야)

- 효율성 최적화는 일반적으로 기능 변경 없이 코드를 수정하는 것이 목표
- 고수준의 관점에서 다음 두 가지 중 하나 또는 모두를 수행하여 최적화를 달성할 수 있다.
    - '낭비된' 자원 소비를 제거
    - 특정 자원 소비를 다른 것으로 대체하거나 고의로 다른 소프트웨어 품질을 희생시키는 것 (트레이드오프)

### 3.1.1 합리적 최적화

- 특정 자원을 사용하여 수행되는 연산 f를 제거했을 때, 그로 인해 아무런 희생도 발생하지 않는다면 f는 '낭비된' 연산이다.
- 연산 f를 제거함으로써 소프트웨어의 효율성을 향상시킬 수 있다.
- 실제로 낭비를 줄여서 효율성을 향상시키는 것은 합리적인 최적화이다.

> 가독성에 주의하자: 낭비를 줄이는 작업이 가독성을 희생시키는 것은 합리적인 최적화가 아니다.

### 3.1.2 의도적 최적화 (Deliberate Optimization)

- 의도적 최적화는 낭비 이상으로 기능에 매우 중요한 작업을 최적화하는 것을 의미한다. 이 경우 트레이드오프(또는 의도하지 않은 결과)가 발생한다.

> 제로섬 게임에 빠졌다: 어떤 자원을 사용하는 특정한 작업을 제거하기 위해 다른 자원이나 다른 특성을 더 소모해야 하는 상황

- 의도적 최적화는 기회 비용을 이해하고 측적하고 평가하여, 이를 유지할지, 버릴지 결정해야 한다.

---

## 3.2 최적화 작업의 어려움

### 개발자들은 성능 문제를 일으키는 부분을 잘 예측하지 못한다

- 파레토 법칙: 프로그램에서 사용한 시간이나 자원의 80%는 프로그램이 수행한 20%의 작업에서 나온다
- 이 점을 염두에 두고 20%의 중요한 작업에 집중해야 한다.

### 개발자들은 정확한 자원 사용을 추정하는 데 소질이 없다

### 시간이 흐를수록 효율성을 유지하는 일은 어렵다

- 시간이 지남에 따라 프로그램이 사용하는 자원이나 프로그램의 특성이 변할 수 있다.
- 자동화나 벤치마크를 통해 효율성을 검증하는 것이 중요하다.

### 성능에 대한 신뢰할 만한 검증을 수행하기는 매우 어렵다

- 동일한 실행 환경을 구성하여 동일한 조건에서 테스트를 수행하기란 매우 어렵다.

### 최적화는 다른 소프트웨어 품질에 쉽게 영향을 끼칠 수 있다

### 특히 Go에서는 메모리 관리에 대한 엄격한 통제를 지원하지 않는다

- Go는 가비지 컬렉션을 사용하기 때문에 메모리를 효율적으로 관리하기 어려울 수 있다.

---