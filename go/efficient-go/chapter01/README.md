# chapter01 소프트웨어 효율성이 중요한 이유

소프트웨어의 런타임이나 공간 복잡도를 개선하는 일은 굉장히 복잡한 주제다. 특히 신입 엔지니어들은 최적화에 많은 시간을 투자하더라도 기대만큼 효율성이 개선되지 않는 경우가 많다. 특히 최신 컴파일러는 자체적으로 최적화를 수행하기도 하고 소프트웨어보다는 하드웨어의 효율성은 개선하는 작업이 더 효율적일 수 있다. 이러한 이유로 엔지니어들은 소프트웨어 성능 최적화를 개발 우선순위에서 뒤로 미루는 경향이 있다.

다만 최적화를 의식적으로 미루는 것과 최적화를 고려하지 않고 개발하는 것은 다르다. 엔지니어들은 최적화를 의식하고 개발을 진행하는 습관을 들여야 한다. 이에 이 저서에서는 데이터를 기반으로 효과적인 개발 습관을 익히는 방법을 소개한다.

## 1.1 성능의 뒷면

성능(Performance)이라는 단어의 명확한 의미는 무엇인가?

소프트웨어 개발 분야의 많은 사람이 '성능'을 '속도'와 동일시하곤 한다. 반면 소프트웨어 개발 분야에 있지 않은 사람들에게 '성능'은 본래의 의미인 품질을 의미한다. 이는 특정 단어가 본래의 뜻이 아닌 다른 의미로 더 많이 사용되는 '시맨틱 확산(Semantic Diffusion)' 현상이다.

성능은 전반적인 실행 품질을 의미하면서도 그보다 더 많은 의미를 내포하고 있다. 따라서 성능이라는 단어를 사용할 때는 어떤 부분에서 어떻게 문제가 발생했고 어떤 부분이 개선되어야 하는지를 명확하게 설명해야 한다.

원칙적으로 소프트웨어 성능은 '소프트웨어가 얼마나 잘 실행되는지'를 의미하며, 다음과 같은 세 가지 요소로 구성된다.

#### 정확도

작업을 완료하기 위해 일을 수행하는 과정에서 발생하는 에러의 수. (내가 실수하고 있지 않은지?)

#### 속도

작업을 완료하기 위해 얼마나 빨리 일을 수행하는지. 작업 수행 시간 또는 처리량으로 평가할 수 있다. (내가 빠르게 일을 하고 있는지?)

#### 효율성

특정 작업을 수행하기 위해 소비하는 자원의 양. 에너지, 메모리, CPU 시간, 발열량 등의 요소들이 있지만, 이를 전부 고려하기는 어렵고 대부분 실용적인 목적을 위해 어떤 요소의 효율성을 따질지 정해야 한다. (내가 일을 지나치게 많이 하고 있거나 자원을 과하게 사용하고 있는지?)

### 정리

성능은 최소한 다음 세 가지 요소를 고려해야 한다.

> 성능 = (정확도 x 효율성 x 속도)

이 중 하나라도 개선되면 시스템의 성능이 향상되며, 부가적인 요소들도 함께 개선된다.
마찬가지로 이 중 하나라도 무시된다면 소프트웨어의 유용성이 줄어든다.

---

## 1.2 효율성에 관한 일반적인 오해

### 1.2.1 최적화된 코드는 가독성이 떨어진다?

코드에 기교를 부리는 것보다 오해가 생기지 않도록 명쾌하게 작성하는 것이 더 중요하다. 이런 관점에서 코드의 가독성이 중요하다. 

일부 최적화방식은 저수준에서 교묘한 수법을 사용하여 이루어진다. 이런 저수준의 최적화 방법들은 코드의 가독성을 현저하게 떨어뜨리지만, 이런 경우는 극히 드물다.

일부 엔지니어들은 최적화가 복잡성을 증가시켜 곧 코드의 가독성을 떨어뜨린다고 생각한다. 그러나 효율성을 최적화한 코드는 명쾌할 수 있고, 효율성과 가독성은 공존할 수 있다.

최적화가 가독성을 해친다는 이러한 견해는 종종 최적화와 반대로 프로그램을 덜 효율적으로 만들게 되는 '섣부른 비관'으로 이어진다.

처음부터 소프트웨어의 효율성을 고려하고 설계하는 것이 최적화나 새로운 기능을 추가할 때 더 깔끔하고, 유지보수하기 쉽고, 좋은 성능을 가진 코드를 만드는 방법이다. 배포 후에는 여러 가지 제약이 생기기 때문에 효율성을 개선하기가 더 어렵다.

#### 최적화한 코드의 가독성이 더 좋을 수 있다

```go
// 최적화하지 않은 코드
type ReportGetter interface {
    Get() []Report
}

func FailureRatio(reports ReportGetter) float64 {
    if len(reports.Get()) == 0 {
        return 0
    }

    var sum float64
    for _, report := range reports.Get() {
        if report.Error() != nil {
            sum++
        }
    }

    return sum / float64(len(reports.Get()))
}
```

```go
// 최적화한 코드
type ReportGetter interface {
    Get() []Report
}

func FailureRatio(reports ReportGetter) float64 {
    reports := reports.Get()
    if len(reports) == 0 {
        return 0
    }

    var sum float64
    for _, report := range reports {
        if report.Error() != nil {
            sum++
        }
    }

    return sum / float64(len(reports))
}
```

1. 최적화하지 않은 코드는 `reports.Get()`을 세 번 호출한다. 이는 `reports`를 세 번 할당하고, 세 번의 메모리 해제를 발생시킨다. 최적화한 코드는 `reports`를 한 번만 할당하고, 한 번의 메모리 해제를 발생시킨다.
2. race condition이 발생할 수 있다. 최적화하지 않은 코드는 `reports.Get()`을 세 번 호출하므로, `reports`의 값이 변경될 수 있다. 최적화한 코드는 `reports`를 한 번만 할당하므로, `reports`의 값이 변경될 수 없다.
3. 최적화한 코드는 한 번의 호출로 변수에 할당하여 사용하므로, 코드의 가독성이 더 좋다.

```go
// 최적화하지 않은 코드
func createSlice(n int) (slice []string) {
    for i := 0; i < n; i++ {
        slice = append(slice, "I", "am", "going", "to", "take", "some", "space")
    }
    return slice
}
```

```go
// 최적화한 코드
func createSlice(n int) []string {
    slice := make([]string, n*7)
    for i := 0; i < n; i++ {
        slice = append(slice, "I", "am", "going", "to", "take", "some", "space")
    }
    return slice
}
```

1. 최적화한 코드는 필요한 메모리를 한 번에 할당하므로, 슬라이스의 크기를 늘리는 작업이 필요하지 않다. 최적화하지 않은 코드는 슬라이스의 크기를 늘리는 작업이 필요하다. 이 때 크기는 2배씩 늘어나므로 불필요한 메모리를 할당할 수 있다.
2. 코드의 의도가 분명하고 명확하게 드러나므로 가독성이 더 좋다.

#### 가독성의 과거와 현재

가독성에 대한 관점은 계속해서 변해왔다. 예를 들어, 과거에는 변수명에 해당 변수의 타입에 대한 내용을 추가하는 헝가리안 표기법이 대세였다.

```go
// 헝가리안 표기법
type structSystem struct {
    sliceU32Numbers []uint32
    bCharacter      byte
    f64Ratio        float64
}
```

과거에는 컴파일러와 통합 개발환경의 성숙도가 낮았기에 이러한 방법이 유용하였다. 그러나 현재는 통합 개발환경은 물론 깃허브와 같은 도구를 통해 코드를 검사하고, 컴파일러는 타입을 추론할 수 있으므로 이러한 방법은 더 이상 필요하지 않다. 성능 최적화도 소프트웨어의 기능처럼 취급되어야 한다.

#### 효율적인 코드의 가독성을 높이는 방법

1. 불필요한 최적화를 제거하자.
2. 인터페이스 등을 활용해 복잡한 코드를 명확한 추상화 수단 뒤에 캡슐화하자.
3. 뜨거운 코드(효율성을 요구하는 중요한 부분)와 차가운 코드(가끔 실행되는 부분)을 분리해 놓자.

### 1.2.2 결국 최적화는 필요 없다?

YAGNI(You aren't going to need it)은 '기능이 필요할 때 만들라'는 뜻으로 소프트웨어 개발에서 많이 사용되는 원칙이다. 이 원칙은 최적화에도 적용된다. 최적화는 필요할 때만 하라는 뜻이다.

YAGNI 원칙을 지키는 것이 중요하지만, 이를 위해 최적화를 완전히 무시해서는 안된다. 대개 문제는 어느 한 곳에 집중되어 있지 않고 작은 코드 부분이 여러 곳에 흩어져 있다. 이러한 작은 부분들은 쉽게 파악하기도, 수정도 어렵다. 요구사항을 충족시키는 것에 앞서 최적화를 고려하고 개발하는 것은 개발자가 가져야 할 좋은 습관이다.

### 1.2.3 더 빨라지고 저렴해지는 하드웨어

시간당 가치를 따져봤을 때, 하드웨어 장치가 개발자보다 저렴하다는 의견이 나올 정도로 하드웨어의 발전은 빠른 속도로 이루어지고 있다. 이는 소프트웨어의 효율성을 개선하는 것보다 하드웨어의 효율성을 개선하는 것이 더 효율적일 수 있다는 의미이다.

이러한 이유로 소프트웨어의 효율성을 개선하는 것은 무의미하다고 생각하는 사람들이 있다. 불행히도 하드웨어의 발전이 소프트웨어의 효율성을 무시하고도 성능 문제들을 해결할 수 있는 것은 아니다. 이에 대한 세 가지 주요한 원인은 다음과 같다.

#### 1. 소프트웨어는 사용 가능한 메모리를 차지하기 위해 확장한다

이 효과는 파킨슨의 법칙이라고도 불린다. 소프트웨어는 하드웨어의 발전으로 인해 더 많은 메모리를 사용할 수 있게 되었고, 이를 통해 더 많은 기능을 제공하게 되었다. 결국 수요가 증가하면서 공급에 맞춰진다는 의미이다.

#### 2. 소프트웨어는 하드웨어가 빨라지는 것보다 더 급격히 느려진다

소프트웨어는 더 나은 사용자 경험을 제공하기 위해 더 많은 기능을 제공하고, 더 많은 기능을 제공하기 위해 더 많은 메모리를 사용한다. 거기에 더해 소프트웨어는 거의 모든 전자기기에서 사용되면서 사용자와 상호작용하고 사용자의 요구사항을 충족시키기 위해 더 많은 것들을 요구한다. 결국 소프트웨어는 더 느려지고 복잡해지면서, 하드웨어가 빨라지는 것보다 더 느려지는 경향이 있다.

#### 3. 기술의 근본적인 한계

무어의 법칙은 1965년에 제안된 법칙으로, 반도체의 집적도가 18개월마다 2배씩 증가한다는 내용이다. 이 법칙은 2006년 즈음 데나드의 규칙에 따른 물리적 한계에 부딪혔다. 작은 트랜지스터를 밀도 있게 모은 것이 전력 소모량이 적다는 것은 사실이나, 더 많은 열을 발생시킨다. 따라서 냉각 시스템을 위한 더 많은 전력과 비용이 필요하다. 이러한 이유로 하드웨어의 발전은 한계에 부딪히고 있다.

#### 정리

하드웨어가 꾸준히 빨라지고 저렴해진다고 해서 소프트웨어를 최적화할 필요가 없다는 생각은 버려야 한다. 개발 과정에서 이러한 생각을 가지고 있다면, 결국은 코드의 효율성을 저하시키고 더 많은 하드웨어 자원을 필요로 하게 될 것이다. 2022년 기준으로 하드웨어는 소프트웨어의 요구를 충족시킬 만큼 빠르게 발전하고 있지 않다.

#### 효율성은 접근성과 포괄성을 개선한다

소프트웨어를 사용하는 많은 사용자는 오래된 하드웨어나 최악의 인터넷 환경에 놓여있다는 사실을 인지해야 한다. 이러한 사용자들을 위해 소프트웨어의 효율성을 개선하는 것은 전반적인 접근성과 포괄성을 개선하는 가치가 있다.


### 1.2.4 수평적 확장을 하면 된다?

#### 수직적 확장성

수직적 확장성은 하드웨어의 성능을 개선하는 것이다. 수직적 확장은 물리적인 한계가 있다.

#### 수평적 확장성

수평적 확장성은 하드웨어의 성능을 개선하는 것이 아니라, 하드웨어의 개수를 늘리는 것이다. 수직적 확장에 비해 제한이 적고 동적으로 확장할 수 있다.

반면 소프트웨어 단에서의 수평적 확장은 하드웨어에 비해 구현하기가 어렵다. 따라서 상황에 따른 선택이 필요하다.

섣부른 확장성 적용은 섣부른 효율성 최적화보다 더 나쁘다. 복잡한 확장성 기능을 도입하기 전, 코드 수준의 알고리즘 최적화를 먼저 고려해야 한다.

### 1.2.5 효율성보다는 출시 시기가 더 중요하다?

시장에 빠르게 진출해 시장 점유율을 높이는 것은 중요하다. 그러나 출시 시기를 빠르게 하기 위해 효율성을 고려하지 않는 것은 좋지 않다. 출시 시기를 빠르게 하기 위해 효율성을 고려하지 않으면, 출시 후에 효율성을 개선하기 위해 더 많은 시간을 투자해야 한다. 더욱이 환불, 투자 취소, 사용자의 불만 등의 문제가 발생할 수 있다.

실제 시장에서는 제품의 일부 기능을 빼는 경우가 생기더라도 RAM 또는 디스크 스토리지 사용을 줄이기 위해 마이그레이션을 진행하는 경우가 많다.

---

## 1.3 코드의 성능을 끌어올리는 열쇠

### 속도보다 효율성을 먼저 고려해야 하는 이유

#### 1. 효율적인 소프트웨어를 느리게 만드는 것이 훨씬 더 어렵다

효율적인 코드는 수행해야 할 작업 자체가 적기에 일반적으로 수행 속도가 더 빠르다.

#### 2. 속도가 더 다루기 어렵다

프로그램의 속돌를 늦출 수 있는 숨은 요인들이 너무나도 많다.

#### 3. 속도는 이식성이 떨어진다

속도만을 최적화한다면, 다른 황경에서 동일하게 빠르게 동작하리라는 보장이 없다. 속도는 하드웨어, 운영체제 등의 영향을 받는다.
반면 효율성은 이식성이 높다. 효율적인 소프트웨어는 동일한 동작을 수행하므로 다른 환경에서도 동일한 효율성을 보장한다.

---

### 1.4 마치며

1. 최적화를 고려하고 개발하는 습관을 들이자.
2. 개발 초기 단계부터 효율성을 고려하자.
3. 성능을 향상시키고 싶다면 효율성을 먼저 개선하자.