# chapter02 효율적인 Go 언어

## 2.1 Go에 대해 알아야 할 기본 사항들

### 2.1.1 명령형, 컴파일형 및 정적 타입 언어

- Go 프로젝트의 핵심은 Go가 '시스템 프로그래밍을 위해 설계된, 프로젝트 이름과 동일한 이름의 범용 언어'라는 점이다.
- Go는 명령형 언어로 실행 방법을 일부 제어할 수 있다.
- 정적으로 타입이 지정되고 컴파일되므로 컴파일러는 많은 최적화 및 검사를 실행할 수 있다.

### 2.1.2 코드베이스 개선을 위한 설계

- Go는 C++의 주요 어려움을 해결하기 위한 설계를 포함한다.
- Go의 기본 원칙은 반복을 덜 하게 만들면서 보안을 포기하지 않고 더 간단한 코드를 허용하는 언어를 만드는 것이다.
- Go는 실행 효율성을 희생하지 않으면서도 빠른 빌드 시간을 보장한다. (명시적 가져오기, 캐싱이 활성화된 상태에서 변경된 코드만 다시 빌드 등)
- 구문적으로 Go는 단순하고 키워드가 적으며 친숙하다. (타입 파생이 있는 C를 기반, 전방 선언 및 헤더 파일이 없음)
- 직교성이 높은 언어로 모든 타입 또는 데이터 정의에 메서드를 추가할 수 있다.

### 2.1.3 구글이 관리하는 오픈소스

- Go는 구글이 관리하는 오픈소스 프로젝트이다.
- 누구나 기여할 수 있지만, Go 팀의 통제된 프로세스를 통해 코드를 검토받아야 한다.

### 2.1.4 단순성, 안전성, 가독성

- Go는 '적을수록 좋다'는 원칙을 따라 단 하나의 관용적인 코딩 스타일이 있으며 `gofmt`라는 도구가 이를 보장한다.
- 창시자가 한 가지 방법만으로 특정 구조를 작성해서 최소한으로 언어를 계획했기 때문에 개발자가 코드를 작성할 때 해야 할 의사결정을 줄일 수 있다.
- 다른 언어에 비해 여러 기능이 누락되었을지라도, 표현력은 더 뛰어나다. Go 코드는 단순성과 가독성이 뛰어나며, 소프트웨어 신뢰성, 안전성 및 애플리케이션 목표를 향한 전반적인 속도를 향상시킨다.

### 2.1.5 패키징 및 모듈

- Go 소스 코드는 패키지 또는 모듈을 나타내는 디렉터리로 구성된다.
- 패키지는 동일한 디렉터리에 있는 소스 파일의 모음이다. 패키지 이름은 각 소스 파일의 맨 위에 있는 `package`문으로 지정된다. 동일한 디렉터리에 있는 모든 소스 파일은 동일한 패키지 이름이어야 한다.
- 모듈은 패키지의 집합이다. 모듈은 `go.mod`라는 파일에 의해 정의된다.
- 일부 실행이 가능한 패키지가 있다. 예를 들어, `main` 패키지는 `main()` 함수를 포함하고 있으며 쉽게 찾을 수 있게 `cmd` 디렉터리에 위치한다. 실행 가능한 패키지는 불러올 수 없고 빌드하거나 실행만 가능하다.
- 패키지에서 네이밍 케이스를 사용하여 접근성을 제어할 수 있다. 구문 이름을 대문자로 시작하면 외부에서 접근할 수 있고, 소문자로 시작하면 외부에서 접근할 수 없다.
- `internal` 디렉터리에 있는 패키지는 해당 모듈의 다른 패키지에서만 임포트할 수 있으며, 외부에서는 임포트할 수 없다.

### 2.1.6 자연스러운 종속성

- Go는 미리 컴파일된 라이브러리를 불러오는 것이 아닌, '가져오기 경로(import path)'라는 패키지 URI를 사용하여 각 라이브러리의 부분을 명시적으로 가져옴으로써 소스 코드를 기반으로 종속성을 관리한다. 사용하지 않는 가져오기나 순환 종속성이 발견된다면 컴파일러는 에러를 발생시킨다.

```go
package main

import (
    "context" // 표준 라이브러리의 패키지 (도메인 이름이 없음)
    _ "net/http/pprof" // 패키지를 불러오지만 어떤 구조도 참조하지 않음. 일부 전역 변수를 초기화하기 위해 사용

    "github.com/oklog/run" // 표준 패키지 외에 도메인 이름 형식의 가져오기 경로와 패키지 경로를 사용하여 외부 패키지를 가져옴

    "example/foo" // 현재 모듈 이름이 example이고 foo 패키지를 가져올 때 사용
)
```

- 이 모델은 개방적이고 명확하게 정의된 종속성에 중점을 둔다. 특히 오픈 소스 배포 모델과 잘 어울린다.
- Go의 표준 라이브러리는 하나의 기능을 위해 큰 라이브러리를 가져오기보다 약간의 코드를 복사하는 식으로 설계되었다. 이처럼 효율성과 투명성을 염두에 둔 종속성 관리는 다음과 같은 가치를 가진다.
    - 하나의 라이브러리 내에서 관련된 코드를 찾기가 쉬우므로 에러 또는 병목 현상을 빠르게 감지할 수 있고 가치 최적화에 집중할 수 있다.

### 2.1.7 일관성 있는 개발 도구들

- Go는 CLI 도구로서 `go`라고 불리는 강력하고 일관적인 개발 도구들을 제공한다.

1. `go bug`: 버그를 제보하기 위한 도구
2. `go build`: 패키지 또는 모듈을 빌드하는 도구
3. `go env`: 환경 변수를 출력하는 도구
4. `go fmt`: 코드를 정렬하는 도구
5. `goimports`: import문을 정리하는 도구
6. `go get`: 패키지를 가져오는 도구
7. `go help`: 도움말을 출력하는 도구
8. `go install`: `go get`과 유사하지만 패키지가 실행가능한 경우 바이너리를 설치한다.
9. `go list`: 패키지 목록을 출력하는 도구
10. `go mod`: 모듈을 관리하는 도구
11. `go test`: 테스트를 실행하는 도구
12. `go tool`: 12개 이상의 고급 CLI 도구를 호스팅
13. `go vet`: 기본 정적 분석 검사를 실행하는 도구

### 2.1.8 에러를 다루는 방법

- 대부분의 프로그래밍 언어는 에러를 특정한 방법으로 처리하는 것을 권장하거나 시행하지 않는다. 많은 방법이 있고 어떤 방법이 가장 좋은지는 프로그래머에게 달려있다. 이로 인해 복잡성이 증가하고, 결과적으로 소프트웨어 신뢰성 문제가 발생할 수 있다.
- 반면 Go는 에러를 일급 객체(first-citizen)로 처리하는 고유한 특징을 가진다.

```go
func noErrCanHappen() int {
    // ...
    return 204
}

func doOrErr() error {
    // ...
    if shouldFail() {
        return errors.New("ups, XYZ failed")
    }
    return nil
}

func intOrErr() (int, error) {
    // ...
    if shouldFail() {
        return 0, errors.New("ups, XYZ failed")
    }
    return noErrCanHappen(), nil
}
```

- 이 예제에서 중요한 점은 함수나 메서드가 시그니처의 일부로 에러 흐름을 정의한다는 것이다. noErrCanHappen 함수는 에러가 발생하지 않는다. doOrErr 함수는 에러가 발생할 수 있으며, 내장 error 인터페이스를 구현하는 값 또는 nil을 반환한다. intOrErr 함수는 여러 반환 값을 가지며, 에러가 발생할 수 있다. 여러 값이 반환되는 경우, 에러는 마지막 반환 값이어야 한다.

- Go는 에러를 정의하고 처리하는 방법이 유일하다는 장점이 있다. 그러나 아이러니하게도 이 특정 보일러플레이트로 인해 코드가 장황해진다는 것이 Go의 단점이기도 하다.
- Go의 에러는 눈에 잘 띄기 때문에 에러를 무시하는 것이 어렵고 무시해서도 안 된다. 만약 에러를 무시해야 한다면 `_ = doOrErr()`와 같이 에러를 무시하는 것을 명시적으로 표현해야 한다.

- 일반적인 Go 코드 런타임 효율성과 관련해 에러 처리를 하지 않는 것은 다음과 같은 문제를 발생시킨다.
    1. 에러 경로는 일반적으로 흐름 제어 경로보다 훨씬 느리고 비용이 많이 든다. (모니터링, 벤치마킹 단계에서 에러 흐름을 무시하지 않는 경향이 있다.)
    2. 에러 구성에 사람이 읽을 수 있는 메시지를 생성하기 위해 과도한 문자열 조작이 포함되는 경우가 많다.

### 2.1.9 강력한 생태계

- 고품질의 Go 표준 라이브러리, 뛰어난 벤치마킹 기능, 견고한 API, 좋은 문서로 인해 외부 패키지를 가져오지 않고도 많은 일을 할 수 있다.
- Go Playground라 불리는 웹 기반 도구를 사용하여 무언가를 빠르게 테스트하거나 대화형 코드 예제를 공유하기 유용하다.
- Go 템플릿이라는 템플릿 언어를 정의하여 동적 텍스트 또는 HTML을 생성할 수 있다. (Helm 또는 Hugo와 같은 프로젝트에서 사용)

### 2.1.10 사용하지 않는 import 또는 변수로 인한 빌드 에러 발생

- Go는 사용하지 않는 import 또는 변수로 인한 빌드 에러를 발생시킨다. 이는 코드를 더 깨끗하게 유지하고, 불필요한 코드를 제거하고, 불필요한 종속성을 제거하고, 불필요한 빌드를 방지하는 데 도움이 된다.
- 불필요한 import 또는 변수를 남겨두고 싶다면 `_`를 사용하여 무시할 수 있다.

```go
import (
    "fmt"
    _ "net/http/pprof"
)

func main() {
    x := 1
    _ = x
}
```

- 사용하지 않은 struct의 필드, 메서드, 타입은 빌드 에러를 발생시키지 않는다.

### 2.1.11 단위 테스트 및 테이블 테스트

- Go는 테스트를 위한 표준 라이브러리를 제공한다. 테스트는 `*_test.go`라는 파일에 작성되며, `go test` 명령을 사용하여 실행할 수 있다.
- Go는 테스트 파일에 4가지 타입의 함수를 지원한다.
    1. `TestXxx(*testing.T)`: 테스트를 실행하는 함수
    2. `BenchmarkXxx(*testing.B)`: 벤치마크를 실행하는 함수
    3. `ExampleXxx()`: 예제를 실행하는 함수
    4. `FuzzXxx(*testing.F)`: 퍼징을 실행하는 함수

- 다양한 입력과 예상 출력을 정의하여 테이블 테스트를 실행할 수 있다.

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        a, b, expected int
    }{
        {1, 2, 3},
        {2, 3, 5},
        {3, 4, 7},
        {4, 5, 9},
        {5, 6, 11},
    }
    for _, tt := range tests {
        actual := Add(tt.a, tt.b)
        if actual != tt.expected {
            t.Errorf("Add(%d, %d): expected %d, actual %d", tt.a, tt.b, tt.expected, actual)
        }
    }
}
```

---

## 2.2 고급 언어 요소

### 2.2.1 일급 객체인 코드 문서화

- Go는 코드 문서화를 위한 표준 도구인 `godoc`을 제공한다. `godoc`은 코드를 문서화하는 데 사용되는 주석을 읽고, HTML 페이지를 생성하고, 웹 서버를 시작한다.

#### 규칙

1. 패키지 수준의 설명은 항목 맨 위에 `Package <name>` 접두어를 사용하여 시작한다. 파일이 많은 경우 `doc.go` 파일을 사용하여 패키지에 대한 설명을 작성한다.
2. 모든 공용 구문은 구문의 이름으로 시작하여, 완전한 문장의 해설을 제공한다.
3. 알려진 버그는 `// BUG(<name>): <description>` 형식으로 작성한다.
4. 비공개 생성자는 주석을 달 수는 있지만, 문서에는 노출되지 않는다.
5. test 파일에 `Example` 함수를 작성하여 예제를 문서화할 수 있다.
6. 예제에 대한 설명은 `// Output: <description>` 형식으로 작성한다.

### 2.2.2 하위 호환성 및 이식성

- Go는 이전 버전과의 하위 호환성을 보장한다.
- 그러나 효율성이 호환되는지는 보장되지 않는다.
- Go는 다양한 플랫폼에서 실행되는 이식성이 뛰어난 언어이다. 다만 이식성과 관련해서는 런타임을 먼저 살펴봐야 한다.

### 2.2.3 Go 런타임

- Go는 가상머신을 사용하지 않고, Go 코드와 사용된 라이브러리들은 컴파일 타임에 기계어로 완전히 컴파일된다.
- 그런데 프로그램이 실행될 때 백그라운드에서 Go 런타임이 동시에 실행된다. Go 런타임은 다음과 같은 기능을 제공한다.
    1. 메모리 관리
    2. 가비지 컬렉션
    3. 스레드 관리
    4. 네트워킹
    5. 스케줄링
    6. 맵 및 슬라이스의 내부 구현
    7. 타입 정보
    8. 링크 및 로드

### 2.2.4 객체 지향 프로그래밍

- Go는 클래스가 없지만 구조체를 사용하여 객체 지향 프로그래밍을 지원한다.
- 구조체 임베딩을 통해 상속과 유사한 기능을 구현할 수 있다.
- 블로그에 정리한 내용이라 생략

### 2.2.5 제너릭

- Go는 1.18 버전부터 제너릭을 지원한다.
- 제너릭? 매개변수 다형성을 제공하는 프로그래밍 기법
- 제너릭이 사용가능하다는 것은 동일한 작업을 수행하는 두 가지 방법이 있다는 것을 의미

#### 기본 타입들에 대한 제너릭 정렬 구현

```go
package main

import (
	"fmt"
	"sort"

	"golang.org/x/exp/constraints"
)

type genericSortableBasic[T constraints.Ordered] []T

func (s genericSortableBasic[T]) Len() int {
	return len(s)
}

func (s genericSortableBasic[T]) Less(i, j int) bool {
	return s[i] < s[j]
}

func (s genericSortableBasic[T]) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func Example() {
	toSort := []int{20, 10, 1, -20}
	sort.Ints(toSort)

	toSort2 := []float64{20.0, 10.0, 1.0, -20.0}
	sort.Sort(genericSortableBasic[float64](toSort2))
}
```

#### 특정 타입의 객체에 대한 제너릭 정렬 구현

```go
package main

import (
	"sort"
)

type Comparable[T any] interface {
	Compare(T) int
}

type genericSortable[T Comparable[T]] []T

func (s genericSortable[T]) Len() int {
	return len(s)
}

func (s genericSortable[T]) Less(i, j int) bool {
	return s[i].Compare(s[j]) > 0
}

func (s genericSortable[T]) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func genericSort[T Comparable[T]](s []T) {
	sort.Sort(genericSortable[T](s))
}

type block struct {
	// ...
}

func (b block) Compare(other block) int {
	return 0
}

func Example() {
	toSort := []block{ /* ... */ }
	sort.Sort(genericSortable[block](toSort))

	// or

	genericSort[block](toSort)
}
```

#### 오버헤드

- C 언어처럼 구현을 하지 않아 개발자의 작업 속도를 더디게 한다.
- 사용될 각 타입에 대한 코드를 복사하는 단형성화(monomorphization)라는 프로세스를 사용하여 컴파일 시간과 바이너리 크기를 증가시킨다.
- 자바의 인터페이스처럼 박싱(boxing)을 사용할 수 있지만 실행 시간이나 메모리 사용량이 증가한다.

> 제너릭은 코드 유지가 더 복잡해지기 때문에 꼭 필요한 경우에만 사용해야 한다.

> Go는 단형성화와 박싱의 중간에서 딕셔너리와 스텐실링 알고리즘을 사용한다.

---

## 2.3 Go는 정말 빠를까?

- 언어들 사이에 실행 시간과 메모리 사용량을 비교하는 원시적이고 반최적화된 짧은 프로그램으로 벤치마킹을 수행하는 것은 효율성을 위한 프로그래밍의 복잡성 등 실질적인 측면을 효과적으로 보여주지 못한다
- 효율성 측면에서 Go에도 단점이 있다. 메모리 사용량을 제어하기 어려울 수 있다. -> 메모리 또는 CPU 효율성을 보장하기 위한 노력이 필요하다.
- 가비지 컬렉션을 사용하지 않는 언어로 러스트가 있지만 코드를 작성하는 데 더 많은 노력이 필요하다. -> Go의 가비지 컬렉션 성능을 제어하면서도, 소프트웨어를 간결하고 효율적으로 개발하는 방법을 3장에서 알아보자.

