# chapter02 효율적인 Go 언어

## 2.1 Go에 대해 알아야 할 기본 사항들

### 2.1.1 명령형, 컴파일형 및 정적 타입 언어

- Go 프로젝트의 핵심은 Go가 '시스템 프로그래밍을 위해 설계된, 프로젝트 이름과 동일한 이름의 범용 언어'라는 점이다.
- Go는 명령형 언어로 실행 방법을 일부 제어할 수 있다.
- 정적으로 타입이 지정되고 컴파일되므로 컴파일러는 많은 최적화 및 검사를 실행할 수 있다.

### 2.1.2 코드베이스 개선을 위한 설계

- Go는 C++의 주요 어려움을 해결하기 위한 설계를 포함한다.
- Go의 기본 원칙은 반복을 덜 하게 만들면서 보안을 포기하지 않고 더 간단한 코드를 허용하는 언어를 만드는 것이다.
- Go는 실행 효율성을 희생하지 않으면서도 빠른 빌드 시간을 보장한다. (명시적 가져오기, 캐싱이 활성화된 상태에서 변경된 코드만 다시 빌드 등)
- 구문적으로 Go는 단순하고 키워드가 적으며 친숙하다. (타입 파생이 있는 C를 기반, 전방 선언 및 헤더 파일이 없음)
- 직교성이 높은 언어로 모든 타입 또는 데이터 정의에 메서드를 추가할 수 있다.

### 2.1.3 구글이 관리하는 오픈소스

- Go는 구글이 관리하는 오픈소스 프로젝트이다.
- 누구나 기여할 수 있지만, Go 팀의 통제된 프로세스를 통해 코드를 검토받아야 한다.

### 2.1.4 단순성, 안전성, 가독성

- Go는 '적을수록 좋다'는 원칙을 따라 단 하나의 관용적인 코딩 스타일이 있으며 `gofmt`라는 도구가 이를 보장한다.
- 창시자가 한 가지 방법만으로 특정 구조를 작성해서 최소한으로 언어를 계획했기 때문에 개발자가 코드를 작성할 때 해야 할 의사결정을 줄일 수 있다.
- 다른 언어에 비해 여러 기능이 누락되었을지라도, 표현력은 더 뛰어나다. Go 코드는 단순성과 가독성이 뛰어나며, 소프트웨어 신뢰성, 안전성 및 애플리케이션 목표를 향한 전반적인 속도를 향상시킨다.

### 2.1.5 패키징 및 모듈

- Go 소스 코드는 패키지 또는 모듈을 나타내는 디렉터리로 구성된다.
- 패키지는 동일한 디렉터리에 있는 소스 파일의 모음이다. 패키지 이름은 각 소스 파일의 맨 위에 있는 `package`문으로 지정된다. 동일한 디렉터리에 있는 모든 소스 파일은 동일한 패키지 이름이어야 한다.
- 모듈은 패키지의 집합이다. 모듈은 `go.mod`라는 파일에 의해 정의된다.
- 일부 실행이 가능한 패키지가 있다. 예를 들어, `main` 패키지는 `main()` 함수를 포함하고 있으며 쉽게 찾을 수 있게 `cmd` 디렉터리에 위치한다. 실행 가능한 패키지는 불러올 수 없고 빌드하거나 실행만 가능하다.
- 패키지에서 네이밍 케이스를 사용하여 접근성을 제어할 수 있다. 구문 이름을 대문자로 시작하면 외부에서 접근할 수 있고, 소문자로 시작하면 외부에서 접근할 수 없다.
- `internal` 디렉터리에 있는 패키지는 해당 모듈의 다른 패키지에서만 임포트할 수 있으며, 외부에서는 임포트할 수 없다.

### 2.1.6 자연스러운 종속성

- Go는 미리 컴파일된 라이브러리를 불러오는 것이 아닌, '가져오기 경로(import path)'라는 패키지 URI를 사용하여 각 라이브러리의 부분을 명시적으로 가져옴으로써 소스 코드를 기반으로 종속성을 관리한다. 사용하지 않는 가져오기나 순환 종속성이 발견된다면 컴파일러는 에러를 발생시킨다.

```go
package main

import (
    "context" // 표준 라이브러리의 패키지 (도메인 이름이 없음)
    _ "net/http/pprof" // 패키지를 불러오지만 어떤 구조도 참조하지 않음. 일부 전역 변수를 초기화하기 위해 사용

    "github.com/oklog/run" // 표준 패키지 외에 도메인 이름 형식의 가져오기 경로와 패키지 경로를 사용하여 외부 패키지를 가져옴

    "example/foo" // 현재 모듈 이름이 example이고 foo 패키지를 가져올 때 사용
)
```

- 이 모델은 개방적이고 명확하게 정의된 종속성에 중점을 둔다. 특히 오픈 소스 배포 모델과 잘 어울린다.
- Go의 표준 라이브러리는 하나의 기능을 위해 큰 라이브러리를 가져오기보다 약간의 코드를 복사하는 식으로 설계되었다. 이처럼 효율성과 투명성을 염두에 둔 종속성 관리는 다음과 같은 가치를 가진다.
    - 하나의 라이브러리 내에서 관련된 코드를 찾기가 쉬우므로 에러 또는 병목 현상을 빠르게 감지할 수 있고 가치 최적화에 집중할 수 있다.

### 2.1.7 일관성 있는 개발 도구들

- Go는 CLI 도구로서 `go`라고 불리는 강력하고 일관적인 개발 도구들을 제공한다.

1. `go bug`: 버그를 제보하기 위한 도구
2. `go build`: 패키지 또는 모듈을 빌드하는 도구
3. `go env`: 환경 변수를 출력하는 도구
4. `go fmt`: 코드를 정렬하는 도구
5. `goimports`: import문을 정리하는 도구
6. `go get`: 패키지를 가져오는 도구
7. `go help`: 도움말을 출력하는 도구
8. `go install`: `go get`과 유사하지만 패키지가 실행가능한 경우 바이너리를 설치한다.
9. `go list`: 패키지 목록을 출력하는 도구
10. `go mod`: 모듈을 관리하는 도구
11. `go test`: 테스트를 실행하는 도구
12. `go tool`: 12개 이상의 고급 CLI 도구를 호스팅
13. `go vet`: 기본 정적 분석 검사를 실행하는 도구

### 2.1.8 에러를 다루는 방법

- 대부분의 프로그래밍 언어는 에러를 특정한 방법으로 처리하는 것을 권장하거나 시행하지 않는다. 많은 방법이 있고 어떤 방법이 가장 좋은지는 프로그래머에게 달려있다. 이로 인해 복잡성이 증가하고, 결과적으로 소프트웨어 신뢰성 문제가 발생할 수 있다.
- 반면 Go는 에러를 일급 객체(first-citizen)로 처리하는 고유한 특징을 가진다.

```go
func noErrCanHappen() int {
    // ...
    return 204
}

func doOrErr() error {
    // ...
    if shouldFail() {
        return errors.New("ups, XYZ failed")
    }
    return nil
}

func intOrErr() (int, error) {
    // ...
    if shouldFail() {
        return 0, errors.New("ups, XYZ failed")
    }
    return noErrCanHappen(), nil
}
```

- 이 예제에서 중요한 점은 함수나 메서드가 시그니처의 일부로 에러 흐름을 정의한다는 것이다. noErrCanHappen 함수는 에러가 발생하지 않는다. doOrErr 함수는 에러가 발생할 수 있으며, 내장 error 인터페이스를 구현하는 값 또는 nil을 반환한다. intOrErr 함수는 여러 반환 값을 가지며, 에러가 발생할 수 있다. 여러 값이 반환되는 경우, 에러는 마지막 반환 값이어야 한다.

- Go는 에러를 정의하고 처리하는 방법이 유일하다는 장점이 있다. 그러나 아이러니하게도 이 특정 보일러플레이트로 인해 코드가 장황해진다는 것이 Go의 단점이기도 하다.
- Go의 에러는 눈에 잘 띄기 때문에 에러를 무시하는 것이 어렵고 무시해서도 안 된다. 만약 에러를 무시해야 한다면 `_ = doOrErr()`와 같이 에러를 무시하는 것을 명시적으로 표현해야 한다.

- 일반적인 Go 코드 런타임 효율성과 관련해 에러 처리를 하지 않는 것은 다음과 같은 문제를 발생시킨다.
    1. 에러 경로는 일반적으로 흐름 제어 경로보다 훨씬 느리고 비용이 많이 든다. (모니터링, 벤치마킹 단계에서 에러 흐름을 무시하지 않는 경향이 있다.)
    2. 에러 구성에 사람이 읽을 수 있는 메시지를 생성하기 위해 과도한 문자열 조작이 포함되는 경우가 많다.

### 2.1.9 강력한 생태계

- 고품질의 Go 표준 라이브러리, 뛰어난 벤치마킹 기능, 견고한 API, 좋은 문서로 인해 외부 패키지를 가져오지 않고도 많은 일을 할 수 있다.
- Go Playground라 불리는 웹 기반 도구를 사용하여 무언가를 빠르게 테스트하거나 대화형 코드 예제를 공유하기 유용하다.
- Go 템플릿이라는 템플릿 언어를 정의하여 동적 텍스트 또는 HTML을 생성할 수 있다. (Helm 또는 Hugo와 같은 프로젝트에서 사용)

### 2.1.10 사용하지 않는 import 또는 변수로 인한 빌드 에러 발생

- Go는 사용하지 않는 import 또는 변수로 인한 빌드 에러를 발생시킨다. 이는 코드를 더 깨끗하게 유지하고, 불필요한 코드를 제거하고, 불필요한 종속성을 제거하고, 불필요한 빌드를 방지하는 데 도움이 된다.
- 불필요한 import 또는 변수를 남겨두고 싶다면 `_`를 사용하여 무시할 수 있다.

```go
import (
    "fmt"
    _ "net/http/pprof"
)

func main() {
    x := 1
    _ = x
}
```

- 사용하지 않은 struct의 필드, 메서드, 타입은 빌드 에러를 발생시키지 않는다.

### 2.1.11 단위 테스트 및 테이블 테스트

- Go는 테스트를 위한 표준 라이브러리를 제공한다. 테스트는 `*_test.go`라는 파일에 작성되며, `go test` 명령을 사용하여 실행할 수 있다.
- Go는 테스트 파일에 4가지 타입의 함수를 지원한다.
    1. `TestXxx(*testing.T)`: 테스트를 실행하는 함수
    2. `BenchmarkXxx(*testing.B)`: 벤치마크를 실행하는 함수
    3. `ExampleXxx()`: 예제를 실행하는 함수
    4. `FuzzXxx(*testing.F)`: 퍼징을 실행하는 함수

- 다양한 입력과 예상 출력을 정의하여 테이블 테스트를 실행할 수 있다.

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        a, b, expected int
    }{
        {1, 2, 3},
        {2, 3, 5},
        {3, 4, 7},
        {4, 5, 9},
        {5, 6, 11},
    }
    for _, tt := range tests {
        actual := Add(tt.a, tt.b)
        if actual != tt.expected {
            t.Errorf("Add(%d, %d): expected %d, actual %d", tt.a, tt.b, tt.expected, actual)
        }
    }
}
```

---